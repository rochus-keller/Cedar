

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Cedar_COCO_PARSER_H__)
#define Cedar_COCO_PARSER_H__

#include <QStack>
#include <Cedar/CedarSynTree.h>


namespace Cedar {


#undef _T_SIZE
class Lexer;
class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Bang=2,
		_T_Hash=3,
		_T_Lpar=4,
		_T_Rpar=5,
		_T_Star=6,
		_T_Plus=7,
		_T_Comma=8,
		_T_Minus=9,
		_T_2Minus=10,
		_T_Dot=11,
		_T_2Dot=12,
		_T_Slash=13,
		_T_Colon=14,
		_T_Semi=15,
		_T_Lt=16,
		_T_2Lt=17,
		_T_Leq=18,
		_T_Eq=19,
		_T_EqGt=20,
		_T_Gt=21,
		_T_Geq=22,
		_T_2Gt=23,
		_T_At=24,
		_T_Lbrack=25,
		_T_Rbrack=26,
		_T_Hat=27,
		_T_Lbrace=28,
		_T_Bar=29,
		_T_Rbrace=30,
		_T_Tilde=31,
		_T_TildeLt=32,
		_T_TildeEq=33,
		_T_TildeGt=34,
		_T_2Tilde=35,
		_T_2190=36,
		_T_Keywords_=37,
		_T_ABS=38,
		_T_ALL=39,
		_T_AND=40,
		_T_ANY=41,
		_T_APPLY=42,
		_T_ARRAY=43,
		_T_BASE=44,
		_T_BEGIN=45,
		_T_BROADCAST=46,
		_T_CEDAR=47,
		_T_CHECKED=48,
		_T_CODE=49,
		_T_COMPUTED=50,
		_T_CONS=51,
		_T_CONTINUE=52,
		_T_DECREASING=53,
		_T_DEFINITIONS=54,
		_T_DEPENDENT=55,
		_T_DESCRIPTOR=56,
		_T_DIRECTORY=57,
		_T_DO=58,
		_T_ELSE=59,
		_T_ENABLE=60,
		_T_END=61,
		_T_ENDCASE=62,
		_T_ENDLOOP=63,
		_T_ENTRY=64,
		_T_ERROR=65,
		_T_EXIT=66,
		_T_EXITS=67,
		_T_EXPORTS=68,
		_T_FINISHED=69,
		_T_FIRST=70,
		_T_FOR=71,
		_T_FORK=72,
		_T_FRAME=73,
		_T_FREE=74,
		_T_FROM=75,
		_T_GO=76,
		_T_GOTO=77,
		_T_IF=78,
		_T_IMPORTS=79,
		_T_IN=80,
		_T_INLINE=81,
		_T_INTERNAL=82,
		_T_ISTYPE=83,
		_T_JOIN=84,
		_T_LAST=85,
		_T_LENGTH=86,
		_T_LIST=87,
		_T_LOCKS=88,
		_T_LONG=89,
		_T_LOOP=90,
		_T_LOOPHOLE=91,
		_T_MACHINE=92,
		_T_MAX=93,
		_T_MIN=94,
		_T_MOD=95,
		_T_MONITOR=96,
		_T_MONITORED=97,
		_T_NARROW=98,
		_T_NEW=99,
		_T_NIL=100,
		_T_NOT=101,
		_T_NOTIFY=102,
		_T_NULL=103,
		_T_OF=104,
		_T_OPEN=105,
		_T_OR=106,
		_T_ORD=107,
		_T_ORDERED=108,
		_T_OVERLAID=109,
		_T_PACKED=110,
		_T_PAINTED=111,
		_T_POINTER=112,
		_T_PORT=113,
		_T_PRED=114,
		_T_PRIVATE=115,
		_T_PROC=116,
		_T_PROCEDURE=117,
		_T_PROCESS=118,
		_T_PROGRAM=119,
		_T_PUBLIC=120,
		_T_READONLY=121,
		_T_RECORD=122,
		_T_REF=123,
		_T_REJECT=124,
		_T_RELATIVE=125,
		_T_REPEAT=126,
		_T_RESTART=127,
		_T_RESUME=128,
		_T_RETRY=129,
		_T_RETURN=130,
		_T_RETURNS=131,
		_T_SAFE=132,
		_T_SELECT=133,
		_T_SEQUENCE=134,
		_T_SHARES=135,
		_T_SIGNAL=136,
		_T_SIZE=137,
		_T_START=138,
		_T_STATE=139,
		_T_STOP=140,
		_T_SUCC=141,
		_T_THEN=142,
		_T_THROUGH=143,
		_T_TO=144,
		_T_TRANSFER=145,
		_T_TRASH=146,
		_T_TRUSTED=147,
		_T_TYPE=148,
		_T_UNCHECKED=149,
		_T_UNCOUNTED=150,
		_T_UNSAFE=151,
		_T_UNTIL=152,
		_T_USING=153,
		_T_VAL=154,
		_T_VAR=155,
		_T_WAIT=156,
		_T_WHILE=157,
		_T_WITH=158,
		_T_ZONE=159,
		_T_Specials_=160,
		_T_number=161,
		_T_string=162,
		_T_char=163,
		_T_symbol=164,
		_T_n=165,
		_T_Comment=166,
		_T_Eof=167,
		_T_MaxToken_=168
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(int line, int col, int n, const char* ctx, const QString&, const QString& path );

public:
	Lexer *scanner;
	struct Error
	{
		QString msg;
		int row, col;
		QString path;
	};
	QList<Error> errors;
	
	void error(int row, int col, const QString& msg, const QString& path)
	{
		Error e;
		e.row = row;
		e.col = col;
		e.msg = msg;
		e.path = path;
		errors.append(e);
	}

	Token d_cur;
	Token d_next;
	QList<Token> d_comments;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser();

    
Cedar::SynTree d_root;
	QStack<Cedar::SynTree*> d_stack;
	void addTerminal() {
		Cedar::SynTree* n = new Cedar::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}



	Parser(Lexer *scanner);
	~Parser();
	void SemErr(const char* msg);

	void module();
	void directory();
	void defsHead();
	void tilde();
	void defsBody();
	void implHead();
	void implBody();
	void include();
	void locks();
	void imports();
	void shares();
	void safety();
	void arguments();
	void exports();
	void access();
	void open();
	void definition();
	void checking();
	void block();
	void primary();
	void t();
	void entry();
	void initVal();
	void e();
	void default_();
	void declaration();
	void trash();
	void machineCode();
	void s();
	void lhs();
	void catch_();
	void argList();
	void for_();
	void while_();
	void scope();
	void repeat();
	void test();
	void openItem();
	void exits();
	void enable();
	void lastCatch();
	void catchList();
	void catchItem();
	void exit();
	void range();
	void relationTail();
	void disjunct();
	void arg();
	void conjunct();
	void negation();
	void relation();
	void sum();
	void typeName();
	void interval();
	void product();
	void factor();
	void prefixOp();
	void typeOp();
	void new_cons_list();
	void literal();
	void typeConstructor();
	void qualifiedName();
	void typeApplication();
	void element();
	void fields();
	void id();
	void field();
	void field_or_nfield();
	void variant();
	void union_();
	void sequence();
	void nvariant();
	void tag();
	void params();

	void Parse();

}; // end Parser

} // namespace


#endif

