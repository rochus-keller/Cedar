

// This file was automatically generated by Coco/R; don't modify it.
#include "CedarParser.h"
#include "CedarLexer.h"


namespace Cedar {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}

void Parser::RunParser()
{
    d_stack.push(&d_root);
    Parse();
    d_stack.pop();
}
    
void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
       SynErr(d_next.d_lineNr, d_next.d_colNr, n, ctx, QString(), d_next.d_sourcePath);
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist)
		error(d_cur.d_lineNr, d_cur.d_colNr, msg, d_cur.d_sourcePath);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Cedar::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
                error( d_next.d_lineNr, d_next.d_colNr, d_next.d_val, d_next.d_sourcePath );
            // else errors already handeled in lexer
            break;
        case Cedar::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Cedar::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::module() {
		d_stack.push(&d_root); 
		if (la->kind == _T_DIRECTORY) {
			directory();
		}
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_CEDAR) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _T_DEFINITIONS) {
			defsHead();
			tilde();
			defsBody();
		} else if (StartOf(1)) {
			implHead();
			tilde();
			implBody();
		} else SynErr(170,__FUNCTION__);
		Expect(_T_Dot,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::directory() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_directory, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_DIRECTORY,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_n) {
			include();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				include();
			}
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::defsHead() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_defsHead, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_DEFINITIONS,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_LOCKS) {
			locks();
		}
		if (la->kind == _T_IMPORTS) {
			imports();
		}
		if (la->kind == _T_SHARES) {
			shares();
		}
		d_stack.pop(); 
}

void Parser::tilde() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_tilde, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Tilde) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
		} else SynErr(171,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::defsBody() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_defsBody, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
			access();
		}
		if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			if (la->kind == _T_OPEN) {
				open();
			}
			definition();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				if (la->kind == _T_n) {
					definition();
				}
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_BEGIN) {
			Get();
			addTerminal(); 
			if (la->kind == _T_OPEN) {
				open();
			}
			definition();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				if (la->kind == _T_n) {
					definition();
				}
			}
			Expect(_T_END,__FUNCTION__);
			addTerminal(); 
		} else SynErr(172,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::implHead() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_implHead, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_SAFE || la->kind == _T_UNSAFE) {
			safety();
		}
		if (la->kind == _T_PROGRAM) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_MONITOR) {
			Get();
			addTerminal(); 
		} else SynErr(173,__FUNCTION__);
		arguments();
		if (la->kind == _T_LOCKS) {
			locks();
		}
		if (la->kind == _T_IMPORTS) {
			imports();
		}
		if (la->kind == _T_EXPORTS) {
			exports();
		}
		if (la->kind == _T_SHARES) {
			shares();
		}
		d_stack.pop(); 
}

void Parser::implBody() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_implBody, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
			access();
		}
		if (la->kind == _T_CHECKED || la->kind == _T_TRUSTED || la->kind == _T_UNCHECKED) {
			checking();
		}
		block();
		d_stack.pop(); 
}

void Parser::include() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_include, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			if (la->kind == _T_TYPE) {
				Get();
				addTerminal(); 
				if (la->kind == _T_n) {
					Get();
					addTerminal(); 
				}
			} else if (la->kind == _T_FROM) {
				Get();
				addTerminal(); 
				Expect(_T_string,__FUNCTION__);
				addTerminal(); 
			} else SynErr(174,__FUNCTION__);
		}
		if (la->kind == _T_USING) {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_n) {
				Get();
				addTerminal(); 
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					Expect(_T_n,__FUNCTION__);
					addTerminal(); 
				}
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::locks() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_locks, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_LOCKS,__FUNCTION__);
		addTerminal(); 
		primary();
		if (la->kind == _T_USING) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			t();
		}
		d_stack.pop(); 
}

void Parser::imports() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_imports, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_IMPORTS,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_n) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
				Expect(_T_n,__FUNCTION__);
				addTerminal(); 
			}
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				Expect(_T_n,__FUNCTION__);
				addTerminal(); 
				if (la->kind == _T_Colon) {
					Get();
					addTerminal(); 
					Expect(_T_n,__FUNCTION__);
					addTerminal(); 
				}
			}
		}
		d_stack.pop(); 
}

void Parser::shares() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_shares, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SHARES,__FUNCTION__);
		addTerminal(); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::safety() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_safety, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_SAFE) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_UNSAFE) {
			Get();
			addTerminal(); 
		} else SynErr(175,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::arguments() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_arguments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrack || la->kind == _T_ANY || la->kind == _T_RETURNS) {
			if (la->kind == _T_RETURNS) {
				Get();
				addTerminal(); 
			}
			params();
		}
		d_stack.pop(); 
}

void Parser::exports() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_exports, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_EXPORTS,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_n) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
				Expect(_T_n,__FUNCTION__);
				addTerminal(); 
			}
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				Expect(_T_n,__FUNCTION__);
				addTerminal(); 
				if (la->kind == _T_Colon) {
					Get();
					addTerminal(); 
					Expect(_T_n,__FUNCTION__);
					addTerminal(); 
				}
			}
		}
		d_stack.pop(); 
}

void Parser::access() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_access, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_PUBLIC) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_PRIVATE) {
			Get();
			addTerminal(); 
		} else SynErr(176,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::open() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_open, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_OPEN,__FUNCTION__);
		addTerminal(); 
		openItem();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			openItem();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::definition() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_definition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
			access();
		}
		if (StartOf(2)) {
			if (la->kind == _T_ENTRY || la->kind == _T_INTERNAL || la->kind == _T_READONLY) {
				if (la->kind == _T_ENTRY || la->kind == _T_INTERNAL) {
					entry();
				} else {
					Get();
					addTerminal(); 
				}
			}
			t();
			if (la->kind == _T_Eq || la->kind == _T_Tilde) {
				tilde();
				initVal();
			}
		} else if (la->kind == _T_TYPE) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Eq || la->kind == _T_Lbrack || la->kind == _T_Tilde) {
				if (la->kind == _T_Lbrack) {
					Get();
					addTerminal(); 
					e();
					Expect(_T_Rbrack,__FUNCTION__);
					addTerminal(); 
				} else {
					tilde();
					if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
						access();
					}
					t();
					if (la->kind == _T_2190) {
						default_();
					}
				}
			}
		} else SynErr(177,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::checking() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_checking, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_CHECKED) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_TRUSTED) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_UNCHECKED) {
			Get();
			addTerminal(); 
		} else SynErr(178,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::block() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			scope();
			if (la->kind == _T_EXITS) {
				exits();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_BEGIN) {
			Get();
			addTerminal(); 
			scope();
			if (la->kind == _T_EXITS) {
				exits();
			}
			Expect(_T_END,__FUNCTION__);
			addTerminal(); 
		} else SynErr(179,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::primary() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lbrack: {
			Get();
			addTerminal(); 
			argList();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_ABS: case _T_BASE: case _T_LENGTH: case _T_LONG: case _T_MAX: case _T_MIN: case _T_ORD: case _T_PRED: case _T_SUCC: {
			prefixOp();
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			arg();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				arg();
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_ALL: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			arg();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_VAL: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			arg();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_ISTYPE: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			e();
			Expect(_T_Comma,__FUNCTION__);
			addTerminal(); 
			t();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_CODE: case _T_FIRST: case _T_LAST: case _T_NIL: case _T_SIZE: {
			typeOp();
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			t();
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				e();
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_Lpar: case _T_APPLY: case _T_LOOPHOLE: case _T_NARROW: case _T_number: case _T_string: case _T_char: case _T_symbol: case _T_n: {
			lhs();
			if (peek(1) == _T_Dot && ( peek(2) == _T_CONS || peek(2) == _T_LIST || peek(2) == _T_NEW ) ) {
				Expect(_T_Dot,__FUNCTION__);
				addTerminal(); 
				new_cons_list();
			}
			break;
		}
		case _T_CONS: case _T_LIST: case _T_NEW: {
			new_cons_list();
			break;
		}
		case _T_DESCRIPTOR: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			e();
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				e();
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					t();
				}
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_At: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		default: SynErr(180,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::t() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_t, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		typeConstructor();
		d_stack.pop(); 
}

void Parser::entry() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_entry, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_ENTRY) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_INTERNAL) {
			Get();
			addTerminal(); 
		} else SynErr(181,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::initVal() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_initVal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(3)) {
			e();
		} else if (la->kind == _T_NULL || la->kind == _T_TRASH) {
			trash();
		} else if (StartOf(4)) {
			if (la->kind == _T_CHECKED || la->kind == _T_TRUSTED || la->kind == _T_UNCHECKED) {
				checking();
			}
			if (la->kind == _T_Lbrace || la->kind == _T_BEGIN || la->kind == _T_INLINE) {
				if (la->kind == _T_INLINE) {
					Get();
					addTerminal(); 
				}
				block();
			} else if (la->kind == _T_MACHINE) {
				Get();
				addTerminal(); 
				Expect(_T_CODE,__FUNCTION__);
				addTerminal(); 
				machineCode();
			} else SynErr(182,__FUNCTION__);
		} else SynErr(183,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::e() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_e, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lpar: case _T_Plus: case _T_Minus: case _T_At: case _T_Lbrack: case _T_Tilde: case _T_ABS: case _T_ALL: case _T_APPLY: case _T_BASE: case _T_CODE: case _T_CONS: case _T_DESCRIPTOR: case _T_FIRST: case _T_ISTYPE: case _T_LAST: case _T_LENGTH: case _T_LIST: case _T_LONG: case _T_LOOPHOLE: case _T_MAX: case _T_MIN: case _T_NARROW: case _T_NEW: case _T_NIL: case _T_NOT: case _T_ORD: case _T_PRED: case _T_SIZE: case _T_SUCC: case _T_VAL: case _T_number: case _T_string: case _T_char: case _T_symbol: case _T_n: {
			disjunct();
			if (la->kind == _T_2190) {
				Get();
				addTerminal(); 
				e();
			}
			break;
		}
		case _T_IF: {
			Get();
			addTerminal(); 
			e();
			Expect(_T_THEN,__FUNCTION__);
			addTerminal(); 
			e();
			Expect(_T_ELSE,__FUNCTION__);
			addTerminal(); 
			e();
			break;
		}
		case _T_SELECT: {
			Get();
			addTerminal(); 
			e();
			Expect(_T_FROM,__FUNCTION__);
			addTerminal(); 
			if (StartOf(5)) {
				test();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					test();
				}
				Expect(_T_EqGt,__FUNCTION__);
				addTerminal(); 
				e();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					if (StartOf(5)) {
						test();
						while (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							test();
						}
						Expect(_T_EqGt,__FUNCTION__);
						addTerminal(); 
						e();
					}
				}
			}
			Expect(_T_ENDCASE,__FUNCTION__);
			addTerminal(); 
			Expect(_T_EqGt,__FUNCTION__);
			addTerminal(); 
			e();
			break;
		}
		case _T_WITH: {
			Get();
			addTerminal(); 
			openItem();
			Expect(_T_SELECT,__FUNCTION__);
			addTerminal(); 
			if (StartOf(3)) {
				e();
			}
			Expect(_T_FROM,__FUNCTION__);
			addTerminal(); 
			if (StartOf(3)) {
				e();
				if (la->kind == _T_Colon) {
					Get();
					addTerminal(); 
					t();
				}
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					e();
				}
				Expect(_T_EqGt,__FUNCTION__);
				addTerminal(); 
				e();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					if (StartOf(3)) {
						e();
						if (la->kind == _T_Colon) {
							Get();
							addTerminal(); 
							t();
						}
						while (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							e();
						}
						Expect(_T_EqGt,__FUNCTION__);
						addTerminal(); 
						e();
					}
				}
			}
			Expect(_T_ENDCASE,__FUNCTION__);
			addTerminal(); 
			Expect(_T_EqGt,__FUNCTION__);
			addTerminal(); 
			e();
			break;
		}
		case _T_ERROR: {
			Get();
			addTerminal(); 
			if (StartOf(6)) {
				lhs();
			}
			break;
		}
		case _T_SIGNAL: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_FORK: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_JOIN: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_START: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		default: SynErr(184,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::default_() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_default_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_2190,__FUNCTION__);
		addTerminal(); 
		if (StartOf(7)) {
			if (StartOf(3)) {
				e();
				if (la->kind == _T_Bar) {
					Get();
					addTerminal(); 
					trash();
				}
			} else {
				trash();
			}
		}
		d_stack.pop(); 
}

void Parser::declaration() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
			access();
		}
		if (StartOf(8)) {
			if (la->kind == _T_ENTRY || la->kind == _T_INTERNAL) {
				entry();
			}
			t();
			if (la->kind == _T_Eq || la->kind == _T_Tilde || la->kind == _T_2190) {
				if (la->kind == _T_Eq || la->kind == _T_Tilde) {
					tilde();
				} else {
					Get();
					addTerminal(); 
				}
				initVal();
			}
		} else if (la->kind == _T_TYPE) {
			Get();
			addTerminal(); 
			tilde();
			if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
				access();
			}
			t();
			if (la->kind == _T_2190) {
				default_();
			}
		} else SynErr(185,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::trash() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_trash, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_TRASH) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_NULL) {
			Get();
			addTerminal(); 
		} else SynErr(186,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::machineCode() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_machineCode, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			if (StartOf(3)) {
				e();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					e();
				}
				while (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
					if (StartOf(3)) {
						e();
						while (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							e();
						}
					}
				}
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_BEGIN) {
			Get();
			addTerminal(); 
			if (StartOf(3)) {
				e();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					e();
				}
				while (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
					if (StartOf(3)) {
						e();
						while (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							e();
						}
					}
				}
			}
			Expect(_T_END,__FUNCTION__);
			addTerminal(); 
		} else SynErr(187,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::s() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_s, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_NULL: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lpar: case _T_APPLY: case _T_LOOPHOLE: case _T_NARROW: case _T_number: case _T_string: case _T_char: case _T_symbol: case _T_n: {
			lhs();
			if (la->kind == _T_2190) {
				Get();
				addTerminal(); 
				if (StartOf(3)) {
					e();
				} else if (la->kind == _T_STATE) {
					Get();
					addTerminal(); 
				} else SynErr(188,__FUNCTION__);
			} else if (la->kind == _T_Dot) {
				Get();
				addTerminal(); 
				Expect(_T_FREE,__FUNCTION__);
				addTerminal(); 
				Expect(_T_Lbrack,__FUNCTION__);
				addTerminal(); 
				e();
				if (la->kind == _T_Bang) {
					catch_();
				}
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			} else SynErr(189,__FUNCTION__);
			break;
		}
		case _T_FREE: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			e();
			if (la->kind == _T_Bang) {
				catch_();
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_STATE: {
			Get();
			addTerminal(); 
			Expect(_T_2190,__FUNCTION__);
			addTerminal(); 
			e();
			break;
		}
		case _T_STOP: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lbrack: {
			Get();
			addTerminal(); 
			argList();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			Expect(_T_2190,__FUNCTION__);
			addTerminal(); 
			e();
			break;
		}
		case _T_ERROR: {
			Get();
			addTerminal(); 
			if (StartOf(6)) {
				lhs();
			}
			break;
		}
		case _T_SIGNAL: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_WAIT: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_NOTIFY: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_BROADCAST: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_JOIN: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_EXIT: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LOOP: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_GOTO: {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_GO: {
			Get();
			addTerminal(); 
			Expect(_T_TO,__FUNCTION__);
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_RETURN: {
			Get();
			addTerminal(); 
			if (StartOf(9)) {
				if (la->kind == _T_WITH) {
					Get();
					addTerminal(); 
					if (la->kind == _T_ERROR) {
						Get();
						addTerminal(); 
					}
				}
				lhs();
			}
			break;
		}
		case _T_CONTINUE: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_RETRY: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_REJECT: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_RESUME: {
			Get();
			addTerminal(); 
			if (StartOf(6)) {
				lhs();
			}
			break;
		}
		case _T_Lbrace: case _T_BEGIN: case _T_CHECKED: case _T_TRUSTED: case _T_UNCHECKED: {
			if (la->kind == _T_CHECKED || la->kind == _T_TRUSTED || la->kind == _T_UNCHECKED) {
				checking();
			}
			block();
			break;
		}
		case _T_DO: case _T_FOR: case _T_THROUGH: case _T_UNTIL: case _T_WHILE: {
			if (la->kind == _T_FOR || la->kind == _T_THROUGH) {
				for_();
			}
			if (la->kind == _T_UNTIL || la->kind == _T_WHILE) {
				while_();
			}
			Expect(_T_DO,__FUNCTION__);
			addTerminal(); 
			scope();
			if (la->kind == _T_REPEAT) {
				repeat();
			}
			Expect(_T_ENDLOOP,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_IF: {
			Get();
			addTerminal(); 
			e();
			Expect(_T_THEN,__FUNCTION__);
			addTerminal(); 
			s();
			if (la->kind == _T_ELSE) {
				Get();
				addTerminal(); 
				s();
			}
			break;
		}
		case _T_SELECT: {
			Get();
			addTerminal(); 
			e();
			Expect(_T_FROM,__FUNCTION__);
			addTerminal(); 
			if (StartOf(5)) {
				test();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					test();
				}
				Expect(_T_EqGt,__FUNCTION__);
				addTerminal(); 
				s();
				while (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
					if (StartOf(5)) {
						test();
						while (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							test();
						}
						Expect(_T_EqGt,__FUNCTION__);
						addTerminal(); 
						s();
					}
				}
			}
			Expect(_T_ENDCASE,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_EqGt) {
				Get();
				addTerminal(); 
				s();
			}
			break;
		}
		case _T_WITH: {
			Get();
			addTerminal(); 
			openItem();
			Expect(_T_SELECT,__FUNCTION__);
			addTerminal(); 
			if (StartOf(3)) {
				e();
			}
			Expect(_T_FROM,__FUNCTION__);
			addTerminal(); 
			if (StartOf(3)) {
				e();
				if (la->kind == _T_Colon) {
					Get();
					addTerminal(); 
					t();
				} else if (la->kind == _T_Comma || la->kind == _T_EqGt) {
					while (la->kind == _T_Comma) {
						Get();
						addTerminal(); 
						e();
					}
				} else SynErr(190,__FUNCTION__);
				Expect(_T_EqGt,__FUNCTION__);
				addTerminal(); 
				s();
				while (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
					if (StartOf(3)) {
						e();
						if (la->kind == _T_Colon) {
							Get();
							addTerminal(); 
							t();
						} else if (la->kind == _T_Comma || la->kind == _T_EqGt) {
							while (la->kind == _T_Comma) {
								Get();
								addTerminal(); 
								e();
							}
						} else SynErr(191,__FUNCTION__);
						Expect(_T_EqGt,__FUNCTION__);
						addTerminal(); 
						s();
					}
				}
			}
			Expect(_T_ENDCASE,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_EqGt) {
				Get();
				addTerminal(); 
				s();
			}
			break;
		}
		case _T_START: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_RESTART: {
			Get();
			addTerminal(); 
			lhs();
			break;
		}
		case _T_TRANSFER: {
			Get();
			addTerminal(); 
			Expect(_T_WITH,__FUNCTION__);
			addTerminal(); 
			lhs();
			break;
		}
		default: SynErr(192,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::lhs() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_lhs, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_number: case _T_string: case _T_char: case _T_symbol: {
			literal();
			break;
		}
		case _T_n: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lpar: {
			Get();
			addTerminal(); 
			e();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_APPLY: {
			Get();
			addTerminal(); 
			if (StartOf(3)) {
				e();
				Expect(_T_Comma,__FUNCTION__);
				addTerminal(); 
				e();
				if (la->kind == _T_Bang) {
					catch_();
				}
			}
			break;
		}
		case _T_NARROW: {
			Get();
			addTerminal(); 
			if (StartOf(3)) {
				e();
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					t();
				}
				if (la->kind == _T_Bang) {
					catch_();
				}
			}
			break;
		}
		case _T_LOOPHOLE: {
			Get();
			addTerminal(); 
			if (StartOf(3)) {
				e();
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					t();
				}
			}
			break;
		}
		default: SynErr(193,__FUNCTION__); break;
		}
		while (la->kind == _T_Dot || la->kind == _T_Lbrack || la->kind == _T_Hat) {
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				argList();
				if (la->kind == _T_Bang) {
					catch_();
				}
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			} else if (la->kind == _T_Dot) {
				Get();
				addTerminal(); 
				if (la->kind == _T_n) {
					Get();
					addTerminal(); 
				} else if (StartOf(10)) {
					prefixOp();
				} else if (StartOf(11)) {
					typeOp();
				} else SynErr(194,__FUNCTION__);
			} else {
				Get();
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::catch_() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_catch_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Bang,__FUNCTION__);
		addTerminal(); 
		if (StartOf(12)) {
			catchList();
			if (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::argList() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_argList, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		arg();
		if (la->kind == _T_Colon || la->kind == _T_Tilde) {
			if (la->kind == _T_Tilde) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			arg();
		}
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			arg();
			if (la->kind == _T_Colon || la->kind == _T_Tilde) {
				if (la->kind == _T_Tilde) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
				}
				arg();
			}
		}
		d_stack.pop(); 
}

void Parser::for_() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_for_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_FOR) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
				t();
			}
			if (la->kind == _T_2190) {
				Get();
				addTerminal(); 
				e();
				Expect(_T_Comma,__FUNCTION__);
				addTerminal(); 
				e();
			} else if (la->kind == _T_DECREASING || la->kind == _T_IN) {
				if (la->kind == _T_DECREASING) {
					Get();
					addTerminal(); 
				}
				Expect(_T_IN,__FUNCTION__);
				addTerminal(); 
				range();
			} else SynErr(195,__FUNCTION__);
		} else if (la->kind == _T_THROUGH) {
			Get();
			addTerminal(); 
			range();
		} else SynErr(196,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::while_() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_while_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_WHILE) {
			Get();
			addTerminal(); 
			e();
		} else if (la->kind == _T_UNTIL) {
			Get();
			addTerminal(); 
			e();
		} else SynErr(197,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::scope() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_scope, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_OPEN) {
			open();
		}
		if (la->kind == _T_ENABLE) {
			enable();
		}
		while (la->kind == _T_n) {
			declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(13)) {
			s();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				if (StartOf(13)) {
					s();
				}
			}
		}
		d_stack.pop(); 
}

void Parser::repeat() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_repeat, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_REPEAT,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_n) {
			exit();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				if (la->kind == _T_n) {
					exit();
				}
			}
		}
		if (la->kind == _T_FINISHED) {
			Get();
			addTerminal(); 
			Expect(_T_EqGt,__FUNCTION__);
			addTerminal(); 
			s();
			if (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::test() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_test, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_NOT) {
			Get();
			addTerminal(); 
		}
		if (StartOf(3)) {
			e();
		} else if (StartOf(14)) {
			relationTail();
		} else SynErr(198,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::openItem() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_openItem, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		e();
		if (la->kind == _T_Colon || la->kind == _T_2Tilde) {
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
				e();
			} else {
				Get();
				addTerminal(); 
				e();
			}
		}
		d_stack.pop(); 
}

void Parser::exits() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_exits, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_EXITS,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_n) {
			exit();
			while (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
				if (la->kind == _T_n) {
					exit();
				}
			}
		}
		d_stack.pop(); 
}

void Parser::enable() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_ENABLE,__FUNCTION__);
		addTerminal(); 
		if (StartOf(12)) {
			lastCatch();
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			if (StartOf(12)) {
				catchList();
				if (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
				}
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_BEGIN) {
			Get();
			addTerminal(); 
			if (StartOf(12)) {
				catchList();
				if (la->kind == _T_Semi) {
					Get();
					addTerminal(); 
				}
			}
			Expect(_T_END,__FUNCTION__);
			addTerminal(); 
		} else SynErr(199,__FUNCTION__);
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::lastCatch() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_lastCatch, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(6)) {
			catchItem();
		} else if (la->kind == _T_ANY) {
			Get();
			addTerminal(); 
			Expect(_T_EqGt,__FUNCTION__);
			addTerminal(); 
			s();
		} else SynErr(200,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::catchList() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_catchList, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		lastCatch();
		while (peek(1) == _T_Semi && ( peek(2) == _T_ANY || peek(2) == _T_APPLY || peek(2) == _T_char || peek(2) == _T_LOOPHOLE || peek(2) == _T_Lpar || peek(2) == _T_n || peek(2) == _T_NARROW || peek(2) == _T_number || peek(2) == _T_string || peek(2) == _T_symbol ) ) {
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			lastCatch();
		}
		d_stack.pop(); 
}

void Parser::catchItem() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_catchItem, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		lhs();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			lhs();
		}
		Expect(_T_EqGt,__FUNCTION__);
		addTerminal(); 
		s();
		d_stack.pop(); 
}

void Parser::exit() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_exit, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_EqGt,__FUNCTION__);
		addTerminal(); 
		s();
		d_stack.pop(); 
}

void Parser::range() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_n) {
			typeName();
			if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
				interval();
			}
		} else if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
			interval();
		} else SynErr(201,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::relationTail() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_relationTail, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(15)) {
			switch (la->kind) {
			case _T_Eq: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_Hash: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_Lt: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_Leq: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_Gt: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_Geq: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_TildeLt: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_TildeGt: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_TildeEq: {
				Get();
				addTerminal(); 
				break;
			}
			}
			sum();
		} else if (la->kind == _T_IN) {
			Get();
			addTerminal(); 
			range();
		} else SynErr(202,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::disjunct() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_disjunct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		conjunct();
		while (peek(1) == _T_OR && ( peek(2) == _T_ABS || peek(2) == _T_ALL || peek(2) == _T_APPLY || peek(2) == _T_At || peek(2) == _T_BASE || peek(2) == _T_CODE || peek(2) == _T_CONS || peek(2) == _T_DESCRIPTOR || peek(2) == _T_FIRST || peek(2) == _T_ISTYPE || peek(2) == _T_LAST || peek(2) == _T_Lbrack || peek(2) == _T_LENGTH || peek(2) == _T_LIST || peek(2) == _T_LONG || peek(2) == _T_LOOPHOLE || peek(2) == _T_Lpar || peek(2) == _T_MAX || peek(2) == _T_MIN || peek(2) == _T_Minus || peek(2) == _T_n || peek(2) == _T_NARROW || peek(2) == _T_NEW || peek(2) == _T_NIL || peek(2) == _T_NOT || peek(2) == _T_ORD || peek(2) == _T_Plus || peek(2) == _T_PRED || peek(2) == _T_SIZE || peek(2) == _T_SUCC || peek(2) == _T_Tilde || peek(2) == _T_VAL ) ) {
			Expect(_T_OR,__FUNCTION__);
			addTerminal(); 
			conjunct();
		}
		d_stack.pop(); 
}

void Parser::arg() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_arg, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(3)) {
			e();
		} else if (la->kind == _T_NULL || la->kind == _T_TRASH) {
			trash();
		} else SynErr(203,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conjunct() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_conjunct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		negation();
		while (peek(1) == _T_AND && ( peek(2) == _T_ABS || peek(2) == _T_ALL || peek(2) == _T_APPLY || peek(2) == _T_At || peek(2) == _T_BASE || peek(2) == _T_char || peek(2) == _T_CODE || peek(2) == _T_CONS || peek(2) == _T_DESCRIPTOR || peek(2) == _T_FIRST || peek(2) == _T_ISTYPE || peek(2) == _T_LAST || peek(2) == _T_Lbrack || peek(2) == _T_LENGTH || peek(2) == _T_LIST || peek(2) == _T_LONG || peek(2) == _T_LOOPHOLE || peek(2) == _T_Lpar || peek(2) == _T_MAX || peek(2) == _T_MIN || peek(2) == _T_Minus || peek(2) == _T_n || peek(2) == _T_NARROW || peek(2) == _T_NEW || peek(2) == _T_NIL || peek(2) == _T_NOT || peek(2) == _T_number || peek(2) == _T_ORD || peek(2) == _T_Plus || peek(2) == _T_PRED || peek(2) == _T_SIZE || peek(2) == _T_string || peek(2) == _T_SUCC || peek(2) == _T_symbol || peek(2) == _T_Tilde || peek(2) == _T_VAL ) ) {
			Expect(_T_AND,__FUNCTION__);
			addTerminal(); 
			negation();
		}
		d_stack.pop(); 
}

void Parser::negation() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_negation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Tilde || la->kind == _T_NOT) {
			if (la->kind == _T_NOT) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		relation();
		d_stack.pop(); 
}

void Parser::relation() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_relation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		sum();
		if (StartOf(16)) {
			if (la->kind == _T_NOT) {
				Get();
				addTerminal(); 
			}
			relationTail();
		}
		d_stack.pop(); 
}

void Parser::sum() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_sum, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		product();
		while (la->kind == _T_Plus || la->kind == _T_Minus) {
			if (la->kind == _T_Plus) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			product();
		}
		d_stack.pop(); 
}

void Parser::typeName() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_typeName, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		qualifiedName();
		d_stack.pop(); 
}

void Parser::interval() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_interval, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			e();
			Expect(_T_2Dot,__FUNCTION__);
			addTerminal(); 
			e();
			if (la->kind == _T_Rbrack) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_Rpar) {
				Get();
				addTerminal(); 
			} else SynErr(204,__FUNCTION__);
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			e();
			Expect(_T_2Dot,__FUNCTION__);
			addTerminal(); 
			e();
			if (la->kind == _T_Rbrack) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_Rpar) {
				Get();
				addTerminal(); 
			} else SynErr(205,__FUNCTION__);
		} else SynErr(206,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::product() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_product, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		factor();
		while (la->kind == _T_Star || la->kind == _T_Slash || la->kind == _T_MOD) {
			if (la->kind == _T_Star) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_Slash) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			factor();
		}
		d_stack.pop(); 
}

void Parser::factor() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus || la->kind == _T_Minus) {
			if (la->kind == _T_Plus) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		primary();
		d_stack.pop(); 
}

void Parser::prefixOp() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_prefixOp, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_LONG: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_PRED: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_SUCC: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ORD: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_ABS: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_MIN: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_MAX: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_BASE: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LENGTH: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(207,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::typeOp() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_typeOp, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_FIRST) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_LAST) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_NIL) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_SIZE) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_CODE) {
			Get();
			addTerminal(); 
		} else SynErr(208,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::new_cons_list() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_new_cons_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_NEW) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				t();
				if (la->kind == _T_Eq || la->kind == _T_Tilde || la->kind == _T_2190) {
					if (la->kind == _T_2190) {
						Get();
						addTerminal(); 
						initVal();
					} else {
						tilde();
						initVal();
					}
				}
				if (la->kind == _T_Bang) {
					catch_();
				}
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			} else if (StartOf(6)) {
				lhs();
			} else SynErr(209,__FUNCTION__);
		} else if (la->kind == _T_CONS) {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			argList();
			if (la->kind == _T_Bang) {
				catch_();
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_LIST) {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			argList();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else SynErr(210,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::literal() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_literal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_number) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_string) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_char) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_symbol) {
			Get();
			addTerminal(); 
		} else SynErr(211,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::typeConstructor() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_typeConstructor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_n: {
			typeApplication();
			if (StartOf(17)) {
				if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
					interval();
				}
			} else if (la->kind == _T_PAINTED) {
				Get();
				addTerminal(); 
				t();
			} else if (la->kind == _T_RELATIVE) {
				Get();
				addTerminal(); 
				t();
			} else SynErr(212,__FUNCTION__);
			break;
		}
		case _T_LONG: {
			Get();
			addTerminal(); 
			t();
			break;
		}
		case _T_VAR: {
			Get();
			addTerminal(); 
			t();
			break;
		}
		case _T_Bang: case _T_Hash: case _T_Lpar: case _T_Rpar: case _T_Star: case _T_Plus: case _T_Comma: case _T_Minus: case _T_Dot: case _T_2Dot: case _T_Slash: case _T_Colon: case _T_Semi: case _T_Lt: case _T_Leq: case _T_Eq: case _T_EqGt: case _T_Gt: case _T_Geq: case _T_Lbrack: case _T_Rbrack: case _T_Hat: case _T_Bar: case _T_Rbrace: case _T_Tilde: case _T_TildeLt: case _T_TildeEq: case _T_TildeGt: case _T_2Tilde: case _T_2190: case _T_AND: case _T_DECREASING: case _T_DO: case _T_ELSE: case _T_END: case _T_ENDCASE: case _T_ENDLOOP: case _T_EXITS: case _T_EXPORTS: case _T_FINISHED: case _T_FROM: case _T_IMPORTS: case _T_IN: case _T_MOD: case _T_NOT: case _T_OF: case _T_OR: case _T_REPEAT: case _T_SELECT: case _T_SHARES: case _T_THEN: case _T_UNCOUNTED: case _T_UNTIL: case _T_USING: case _T_WHILE: {
			if (la->kind == _T_UNCOUNTED) {
				Get();
				addTerminal(); 
				Expect(_T_ZONE,__FUNCTION__);
				addTerminal(); 
			}
			break;
		}
		case _T_Lbrace: case _T_MACHINE: case _T_MONITORED: case _T_RECORD: {
			if (la->kind == _T_MACHINE) {
				Get();
				addTerminal(); 
				Expect(_T_DEPENDENT,__FUNCTION__);
				addTerminal(); 
			}
			if (la->kind == _T_Lbrace) {
				Get();
				addTerminal(); 
				if (la->kind == _T_Lpar || la->kind == _T_n) {
					element();
					while (la->kind == _T_Comma) {
						Get();
						addTerminal(); 
						element();
					}
				}
				Expect(_T_Rbrace,__FUNCTION__);
				addTerminal(); 
			} else if (la->kind == _T_MONITORED || la->kind == _T_RECORD) {
				if (la->kind == _T_MONITORED) {
					Get();
					addTerminal(); 
				}
				Expect(_T_RECORD,__FUNCTION__);
				addTerminal(); 
				fields();
			} else SynErr(213,__FUNCTION__);
			break;
		}
		case _T_ARRAY: case _T_PACKED: {
			if (la->kind == _T_PACKED) {
				Get();
				addTerminal(); 
			}
			Expect(_T_ARRAY,__FUNCTION__);
			addTerminal(); 
			if (StartOf(18)) {
				t();
			}
			Expect(_T_OF,__FUNCTION__);
			addTerminal(); 
			t();
			break;
		}
		case _T_ERROR: case _T_PORT: case _T_PROC: case _T_PROCEDURE: case _T_PROCESS: case _T_PROGRAM: case _T_SAFE: case _T_SIGNAL: case _T_UNSAFE: {
			if (la->kind == _T_SAFE || la->kind == _T_UNSAFE) {
				safety();
			}
			switch (la->kind) {
			case _T_PROCEDURE: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_PROC: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_SIGNAL: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_ERROR: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_PROCESS: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_PROGRAM: {
				Get();
				addTerminal(); 
				break;
			}
			case _T_PORT: {
				Get();
				addTerminal(); 
				break;
			}
			default: SynErr(214,__FUNCTION__); break;
			}
			arguments();
			break;
		}
		case _T_REF: {
			Get();
			addTerminal(); 
			if (la->kind == _T_READONLY) {
				Get();
				addTerminal(); 
			}
			if (StartOf(19)) {
				if (StartOf(20)) {
					t();
				} else {
					Get();
					addTerminal(); 
				}
			}
			break;
		}
		case _T_LIST: {
			Get();
			addTerminal(); 
			Expect(_T_OF,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_READONLY) {
				Get();
				addTerminal(); 
			}
			t();
			break;
		}
		case _T_DESCRIPTOR: {
			Get();
			addTerminal(); 
			Expect(_T_FOR,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_READONLY) {
				Get();
				addTerminal(); 
			}
			t();
			break;
		}
		case _T_BASE: case _T_ORDERED: case _T_POINTER: {
			if (la->kind == _T_ORDERED) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_BASE) {
				Get();
				addTerminal(); 
			}
			Expect(_T_POINTER,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
				interval();
			}
			if (la->kind == _T_TO) {
				Get();
				addTerminal(); 
				if (la->kind == _T_READONLY) {
					Get();
					addTerminal(); 
				}
				t();
			}
			break;
		}
		case _T_FRAME: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			break;
		}
		default: SynErr(215,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::qualifiedName() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_qualifiedName, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (peek(1) == _T_n && peek(2) == _T_Dot ) {
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Dot,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::typeApplication() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_typeApplication, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		typeName();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			e();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		while (la->kind == _T_Dot || la->kind == _T_Lbrack) {
			if (la->kind == _T_Dot) {
				Get();
				addTerminal(); 
				Expect(_T_n,__FUNCTION__);
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
				e();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::element() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_element, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_n) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lpar) {
				Get();
				addTerminal(); 
				e();
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			e();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(216,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::fields() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_fields, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_NULL) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			if (( peek(1) == _T_PACKED || peek(1) == _T_SELECT || peek(1) == _T_SEQUENCE ) && ( peek(2) == _T_2190 || peek(2) == _T_COMPUTED || peek(2) == _T_n || peek(2) == _T_OVERLAID || peek(2) == _T_SEQUENCE ) ) {
				variant();
			} else if (StartOf(21)) {
				if (StartOf(22)) {
					field_or_nfield();
					while (la->kind == _T_Comma) {
						Get();
						addTerminal(); 
						field_or_nfield();
					}
					Expect(_T_Comma,__FUNCTION__);
					addTerminal(); 
				}
				if (la->kind == _T_n) {
					nvariant();
				}
			} else SynErr(217,__FUNCTION__);
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else SynErr(218,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::id() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_id, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			e();
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
				e();
				Expect(_T_2Dot,__FUNCTION__);
				addTerminal(); 
				e();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::field() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_field, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		t();
		if (la->kind == _T_2190) {
			default_();
		}
		d_stack.pop(); 
}

void Parser::field_or_nfield() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_field_or_nfield, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		t();
		if (la->kind == _T_Lpar || la->kind == _T_Comma || la->kind == _T_Colon) {
			if (la->kind == _T_Lpar) {
				Get();
				addTerminal(); 
				e();
				if (la->kind == _T_Colon) {
					Get();
					addTerminal(); 
					e();
					Expect(_T_2Dot,__FUNCTION__);
					addTerminal(); 
					e();
				}
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
			while (peek(1) == _T_Comma && peek(2) == _T_n ) {
				Expect(_T_Comma,__FUNCTION__);
				addTerminal(); 
				id();
			}
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
				access();
			}
			field();
		} else if (la->kind == _T_Comma || la->kind == _T_Rbrack || la->kind == _T_2190) {
			if (la->kind == _T_2190) {
				default_();
			}
		} else SynErr(219,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variant() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_variant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_SELECT) {
			union_();
		} else if (la->kind == _T_PACKED || la->kind == _T_SEQUENCE) {
			sequence();
		} else SynErr(220,__FUNCTION__);
		if (la->kind == _T_2190) {
			default_();
		}
		d_stack.pop(); 
}

void Parser::union_() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_union_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SELECT,__FUNCTION__);
		addTerminal(); 
		tag();
		Expect(_T_FROM,__FUNCTION__);
		addTerminal(); 
		Expect(_T_n,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_n,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_EqGt,__FUNCTION__);
		addTerminal(); 
		fields();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_n) {
				Get();
				addTerminal(); 
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					Expect(_T_n,__FUNCTION__);
					addTerminal(); 
				}
				Expect(_T_EqGt,__FUNCTION__);
				addTerminal(); 
				fields();
			}
		}
		Expect(_T_ENDCASE,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::sequence() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_sequence, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_PACKED) {
			Get();
			addTerminal(); 
		}
		Expect(_T_SEQUENCE,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_n) {
			id();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
				access();
			}
		} else if (la->kind == _T_COMPUTED) {
			Get();
			addTerminal(); 
		} else SynErr(221,__FUNCTION__);
		t();
		Expect(_T_OF,__FUNCTION__);
		addTerminal(); 
		t();
		d_stack.pop(); 
}

void Parser::nvariant() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_nvariant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		id();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
			access();
		}
		variant();
		d_stack.pop(); 
}

void Parser::tag() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_tag, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_n) {
			id();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_PRIVATE || la->kind == _T_PUBLIC) {
				access();
			}
		} else if (la->kind == _T_COMPUTED) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_OVERLAID) {
			Get();
			addTerminal(); 
		} else SynErr(222,__FUNCTION__);
		if (StartOf(23)) {
			t();
		} else if (la->kind == _T_Star) {
			Get();
			addTerminal(); 
		} else SynErr(223,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::params() {
		Cedar::SynTree* n = new Cedar::SynTree( Cedar::SynTree::R_params, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			if (StartOf(21)) {
				field_or_nfield();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					field_or_nfield();
				}
			}
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_ANY) {
			Get();
			addTerminal(); 
		} else SynErr(224,__FUNCTION__);
		d_stack.pop(); 
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Token();
	d_next = Token();
	Get();
	module();
	Expect(0,__FUNCTION__);
}

Parser::Parser(Lexer *scanner) {
	maxT = 169;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[24][171] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, T,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,T,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,T, x,x,x,x, x,x,T,T, x,x,T,x, T,x,x,x, x,T,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, T,x,x,x, x,x,T,x, x,x,x,T, T,T,T,T, x,T,x,T, x,T,T,x, x,x,T,T, T,T,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,T, T,x,x,T, x,T,x,x, x,x,x,x, T,x,T,T, x,T,T,x, T,T,x,x, x,x,x,T, T,T,T,x, x,x,T,T, x,x,T,x, T,x,x,x, x,T,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, T,x,x,x, x,x,T,x, T,x,x,T, T,T,T,T, x,T,x,T, x,T,T,x, x,x,T,T, T,T,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,T, x,x,x,x, x,x,T,T, x,x,T,x, T,x,x,x, x,T,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, T,x,x,x, x,x,T,x, x,x,x,T, T,T,T,T, x,T,x,T, x,T,T,x, x,x,T,T, T,T,x,T, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,T,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,T,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,x, T,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,T,x, T,T,T,x, x,x,x,x, T,x,x,x, x,x,T,T, x,x,x,x, x,x,T,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,T,T,x, x,T,x,x, T,x,T,T, T,x,x,T, x,T,x,T, x,T,x,x, T,x,x,x, T,T,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,T, x,T,T,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,T, x,T,T,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,T, x,T,T,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,T,T, T,T,T,T, T,T,x,T, T,T,T,T, T,x,T,T, T,T,T,x, x,T,T,T, x,T,T,T, T,T,T,T, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,T, x,T,T,T, x,x,x,T, T,T,x,x, x,x,x,T, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, T,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,T,T, T,T,T,T, T,T,x,T, T,T,T,T, T,x,T,T, T,T,T,x, x,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, T,x,x,T, T,x,x,x, x,x,x,x, x,T,x,x, T,x,T,T, x,T,T,T, x,T,x,T, T,T,x,x, x,T,x,T, x,x,x,T, T,x,x,x, x,x,x,T, x,T,x,x, T,x,x,T, x,T,x,x, x,T,x,x, T,x,T,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,T,x, x,x,x,x, T,T,x,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,T,T, T,T,x,T, x,T,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,x,x, T,T,T,T, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(int line, int col, int n, const char* ctx, const QString& str, const QString& path ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else if( n <= TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Bang expected"); break;
			case 3: s = coco_string_create(L"T_Hash expected"); break;
			case 4: s = coco_string_create(L"T_Lpar expected"); break;
			case 5: s = coco_string_create(L"T_Rpar expected"); break;
			case 6: s = coco_string_create(L"T_Star expected"); break;
			case 7: s = coco_string_create(L"T_Plus expected"); break;
			case 8: s = coco_string_create(L"T_Comma expected"); break;
			case 9: s = coco_string_create(L"T_Minus expected"); break;
			case 10: s = coco_string_create(L"T_2Minus expected"); break;
			case 11: s = coco_string_create(L"T_Dot expected"); break;
			case 12: s = coco_string_create(L"T_2Dot expected"); break;
			case 13: s = coco_string_create(L"T_Slash expected"); break;
			case 14: s = coco_string_create(L"T_Colon expected"); break;
			case 15: s = coco_string_create(L"T_Semi expected"); break;
			case 16: s = coco_string_create(L"T_Lt expected"); break;
			case 17: s = coco_string_create(L"T_2Lt expected"); break;
			case 18: s = coco_string_create(L"T_Leq expected"); break;
			case 19: s = coco_string_create(L"T_Eq expected"); break;
			case 20: s = coco_string_create(L"T_EqGt expected"); break;
			case 21: s = coco_string_create(L"T_Gt expected"); break;
			case 22: s = coco_string_create(L"T_Geq expected"); break;
			case 23: s = coco_string_create(L"T_2Gt expected"); break;
			case 24: s = coco_string_create(L"T_At expected"); break;
			case 25: s = coco_string_create(L"T_Lbrack expected"); break;
			case 26: s = coco_string_create(L"T_Rbrack expected"); break;
			case 27: s = coco_string_create(L"T_Hat expected"); break;
			case 28: s = coco_string_create(L"T_Lbrace expected"); break;
			case 29: s = coco_string_create(L"T_Bar expected"); break;
			case 30: s = coco_string_create(L"T_Rbrace expected"); break;
			case 31: s = coco_string_create(L"T_Tilde expected"); break;
			case 32: s = coco_string_create(L"T_TildeLt expected"); break;
			case 33: s = coco_string_create(L"T_TildeEq expected"); break;
			case 34: s = coco_string_create(L"T_TildeGt expected"); break;
			case 35: s = coco_string_create(L"T_2Tilde expected"); break;
			case 36: s = coco_string_create(L"T_2190 expected"); break;
			case 37: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 38: s = coco_string_create(L"T_ABS expected"); break;
			case 39: s = coco_string_create(L"T_ALL expected"); break;
			case 40: s = coco_string_create(L"T_AND expected"); break;
			case 41: s = coco_string_create(L"T_ANY expected"); break;
			case 42: s = coco_string_create(L"T_APPLY expected"); break;
			case 43: s = coco_string_create(L"T_ARRAY expected"); break;
			case 44: s = coco_string_create(L"T_BASE expected"); break;
			case 45: s = coco_string_create(L"T_BEGIN expected"); break;
			case 46: s = coco_string_create(L"T_BROADCAST expected"); break;
			case 47: s = coco_string_create(L"T_CEDAR expected"); break;
			case 48: s = coco_string_create(L"T_CHECKED expected"); break;
			case 49: s = coco_string_create(L"T_CODE expected"); break;
			case 50: s = coco_string_create(L"T_COMPUTED expected"); break;
			case 51: s = coco_string_create(L"T_CONS expected"); break;
			case 52: s = coco_string_create(L"T_CONTINUE expected"); break;
			case 53: s = coco_string_create(L"T_DECREASING expected"); break;
			case 54: s = coco_string_create(L"T_DEFINITIONS expected"); break;
			case 55: s = coco_string_create(L"T_DEPENDENT expected"); break;
			case 56: s = coco_string_create(L"T_DESCRIPTOR expected"); break;
			case 57: s = coco_string_create(L"T_DIRECTORY expected"); break;
			case 58: s = coco_string_create(L"T_DO expected"); break;
			case 59: s = coco_string_create(L"T_ELSE expected"); break;
			case 60: s = coco_string_create(L"T_ENABLE expected"); break;
			case 61: s = coco_string_create(L"T_END expected"); break;
			case 62: s = coco_string_create(L"T_ENDCASE expected"); break;
			case 63: s = coco_string_create(L"T_ENDLOOP expected"); break;
			case 64: s = coco_string_create(L"T_ENTRY expected"); break;
			case 65: s = coco_string_create(L"T_ERROR expected"); break;
			case 66: s = coco_string_create(L"T_EXIT expected"); break;
			case 67: s = coco_string_create(L"T_EXITS expected"); break;
			case 68: s = coco_string_create(L"T_EXPORTS expected"); break;
			case 69: s = coco_string_create(L"T_FINISHED expected"); break;
			case 70: s = coco_string_create(L"T_FIRST expected"); break;
			case 71: s = coco_string_create(L"T_FOR expected"); break;
			case 72: s = coco_string_create(L"T_FORK expected"); break;
			case 73: s = coco_string_create(L"T_FRAME expected"); break;
			case 74: s = coco_string_create(L"T_FREE expected"); break;
			case 75: s = coco_string_create(L"T_FROM expected"); break;
			case 76: s = coco_string_create(L"T_GO expected"); break;
			case 77: s = coco_string_create(L"T_GOTO expected"); break;
			case 78: s = coco_string_create(L"T_IF expected"); break;
			case 79: s = coco_string_create(L"T_IMPORTS expected"); break;
			case 80: s = coco_string_create(L"T_IN expected"); break;
			case 81: s = coco_string_create(L"T_INLINE expected"); break;
			case 82: s = coco_string_create(L"T_INTERNAL expected"); break;
			case 83: s = coco_string_create(L"T_ISTYPE expected"); break;
			case 84: s = coco_string_create(L"T_JOIN expected"); break;
			case 85: s = coco_string_create(L"T_LAST expected"); break;
			case 86: s = coco_string_create(L"T_LENGTH expected"); break;
			case 87: s = coco_string_create(L"T_LIST expected"); break;
			case 88: s = coco_string_create(L"T_LOCKS expected"); break;
			case 89: s = coco_string_create(L"T_LONG expected"); break;
			case 90: s = coco_string_create(L"T_LOOP expected"); break;
			case 91: s = coco_string_create(L"T_LOOPHOLE expected"); break;
			case 92: s = coco_string_create(L"T_MACHINE expected"); break;
			case 93: s = coco_string_create(L"T_MAX expected"); break;
			case 94: s = coco_string_create(L"T_MIN expected"); break;
			case 95: s = coco_string_create(L"T_MOD expected"); break;
			case 96: s = coco_string_create(L"T_MONITOR expected"); break;
			case 97: s = coco_string_create(L"T_MONITORED expected"); break;
			case 98: s = coco_string_create(L"T_NARROW expected"); break;
			case 99: s = coco_string_create(L"T_NEW expected"); break;
			case 100: s = coco_string_create(L"T_NIL expected"); break;
			case 101: s = coco_string_create(L"T_NOT expected"); break;
			case 102: s = coco_string_create(L"T_NOTIFY expected"); break;
			case 103: s = coco_string_create(L"T_NULL expected"); break;
			case 104: s = coco_string_create(L"T_OF expected"); break;
			case 105: s = coco_string_create(L"T_OPEN expected"); break;
			case 106: s = coco_string_create(L"T_OR expected"); break;
			case 107: s = coco_string_create(L"T_ORD expected"); break;
			case 108: s = coco_string_create(L"T_ORDERED expected"); break;
			case 109: s = coco_string_create(L"T_OVERLAID expected"); break;
			case 110: s = coco_string_create(L"T_PACKED expected"); break;
			case 111: s = coco_string_create(L"T_PAINTED expected"); break;
			case 112: s = coco_string_create(L"T_POINTER expected"); break;
			case 113: s = coco_string_create(L"T_PORT expected"); break;
			case 114: s = coco_string_create(L"T_PRED expected"); break;
			case 115: s = coco_string_create(L"T_PRIVATE expected"); break;
			case 116: s = coco_string_create(L"T_PROC expected"); break;
			case 117: s = coco_string_create(L"T_PROCEDURE expected"); break;
			case 118: s = coco_string_create(L"T_PROCESS expected"); break;
			case 119: s = coco_string_create(L"T_PROGRAM expected"); break;
			case 120: s = coco_string_create(L"T_PUBLIC expected"); break;
			case 121: s = coco_string_create(L"T_READONLY expected"); break;
			case 122: s = coco_string_create(L"T_RECORD expected"); break;
			case 123: s = coco_string_create(L"T_REF expected"); break;
			case 124: s = coco_string_create(L"T_REJECT expected"); break;
			case 125: s = coco_string_create(L"T_RELATIVE expected"); break;
			case 126: s = coco_string_create(L"T_REPEAT expected"); break;
			case 127: s = coco_string_create(L"T_RESTART expected"); break;
			case 128: s = coco_string_create(L"T_RESUME expected"); break;
			case 129: s = coco_string_create(L"T_RETRY expected"); break;
			case 130: s = coco_string_create(L"T_RETURN expected"); break;
			case 131: s = coco_string_create(L"T_RETURNS expected"); break;
			case 132: s = coco_string_create(L"T_SAFE expected"); break;
			case 133: s = coco_string_create(L"T_SELECT expected"); break;
			case 134: s = coco_string_create(L"T_SEQUENCE expected"); break;
			case 135: s = coco_string_create(L"T_SHARES expected"); break;
			case 136: s = coco_string_create(L"T_SIGNAL expected"); break;
			case 137: s = coco_string_create(L"T_SIZE expected"); break;
			case 138: s = coco_string_create(L"T_START expected"); break;
			case 139: s = coco_string_create(L"T_STATE expected"); break;
			case 140: s = coco_string_create(L"T_STOP expected"); break;
			case 141: s = coco_string_create(L"T_SUCC expected"); break;
			case 142: s = coco_string_create(L"T_THEN expected"); break;
			case 143: s = coco_string_create(L"T_THROUGH expected"); break;
			case 144: s = coco_string_create(L"T_TO expected"); break;
			case 145: s = coco_string_create(L"T_TRANSFER expected"); break;
			case 146: s = coco_string_create(L"T_TRASH expected"); break;
			case 147: s = coco_string_create(L"T_TRUSTED expected"); break;
			case 148: s = coco_string_create(L"T_TYPE expected"); break;
			case 149: s = coco_string_create(L"T_UNCHECKED expected"); break;
			case 150: s = coco_string_create(L"T_UNCOUNTED expected"); break;
			case 151: s = coco_string_create(L"T_UNSAFE expected"); break;
			case 152: s = coco_string_create(L"T_UNTIL expected"); break;
			case 153: s = coco_string_create(L"T_USING expected"); break;
			case 154: s = coco_string_create(L"T_VAL expected"); break;
			case 155: s = coco_string_create(L"T_VAR expected"); break;
			case 156: s = coco_string_create(L"T_WAIT expected"); break;
			case 157: s = coco_string_create(L"T_WHILE expected"); break;
			case 158: s = coco_string_create(L"T_WITH expected"); break;
			case 159: s = coco_string_create(L"T_ZONE expected"); break;
			case 160: s = coco_string_create(L"T_Specials_ expected"); break;
			case 161: s = coco_string_create(L"T_number expected"); break;
			case 162: s = coco_string_create(L"T_string expected"); break;
			case 163: s = coco_string_create(L"T_char expected"); break;
			case 164: s = coco_string_create(L"T_symbol expected"); break;
			case 165: s = coco_string_create(L"T_n expected"); break;
			case 166: s = coco_string_create(L"T_Comment expected"); break;
			case 167: s = coco_string_create(L"T_Eof expected"); break;
			case 168: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 169: s = coco_string_create(L"??? expected"); break;
			case 170: s = coco_string_create(L"invalid module"); break;
			case 171: s = coco_string_create(L"invalid tilde"); break;
			case 172: s = coco_string_create(L"invalid defsBody"); break;
			case 173: s = coco_string_create(L"invalid implHead"); break;
			case 174: s = coco_string_create(L"invalid include"); break;
			case 175: s = coco_string_create(L"invalid safety"); break;
			case 176: s = coco_string_create(L"invalid access"); break;
			case 177: s = coco_string_create(L"invalid definition"); break;
			case 178: s = coco_string_create(L"invalid checking"); break;
			case 179: s = coco_string_create(L"invalid block"); break;
			case 180: s = coco_string_create(L"invalid primary"); break;
			case 181: s = coco_string_create(L"invalid entry"); break;
			case 182: s = coco_string_create(L"invalid initVal"); break;
			case 183: s = coco_string_create(L"invalid initVal"); break;
			case 184: s = coco_string_create(L"invalid e"); break;
			case 185: s = coco_string_create(L"invalid declaration"); break;
			case 186: s = coco_string_create(L"invalid trash"); break;
			case 187: s = coco_string_create(L"invalid machineCode"); break;
			case 188: s = coco_string_create(L"invalid s"); break;
			case 189: s = coco_string_create(L"invalid s"); break;
			case 190: s = coco_string_create(L"invalid s"); break;
			case 191: s = coco_string_create(L"invalid s"); break;
			case 192: s = coco_string_create(L"invalid s"); break;
			case 193: s = coco_string_create(L"invalid lhs"); break;
			case 194: s = coco_string_create(L"invalid lhs"); break;
			case 195: s = coco_string_create(L"invalid for_"); break;
			case 196: s = coco_string_create(L"invalid for_"); break;
			case 197: s = coco_string_create(L"invalid while_"); break;
			case 198: s = coco_string_create(L"invalid test"); break;
			case 199: s = coco_string_create(L"invalid enable"); break;
			case 200: s = coco_string_create(L"invalid lastCatch"); break;
			case 201: s = coco_string_create(L"invalid range"); break;
			case 202: s = coco_string_create(L"invalid relationTail"); break;
			case 203: s = coco_string_create(L"invalid arg"); break;
			case 204: s = coco_string_create(L"invalid interval"); break;
			case 205: s = coco_string_create(L"invalid interval"); break;
			case 206: s = coco_string_create(L"invalid interval"); break;
			case 207: s = coco_string_create(L"invalid prefixOp"); break;
			case 208: s = coco_string_create(L"invalid typeOp"); break;
			case 209: s = coco_string_create(L"invalid new_cons_list"); break;
			case 210: s = coco_string_create(L"invalid new_cons_list"); break;
			case 211: s = coco_string_create(L"invalid literal"); break;
			case 212: s = coco_string_create(L"invalid typeConstructor"); break;
			case 213: s = coco_string_create(L"invalid typeConstructor"); break;
			case 214: s = coco_string_create(L"invalid typeConstructor"); break;
			case 215: s = coco_string_create(L"invalid typeConstructor"); break;
			case 216: s = coco_string_create(L"invalid element"); break;
			case 217: s = coco_string_create(L"invalid fields"); break;
			case 218: s = coco_string_create(L"invalid fields"); break;
			case 219: s = coco_string_create(L"invalid field_or_nfield"); break;
			case 220: s = coco_string_create(L"invalid variant"); break;
			case 221: s = coco_string_create(L"invalid sequence"); break;
			case 222: s = coco_string_create(L"invalid tag"); break;
			case 223: s = coco_string_create(L"invalid tag"); break;
			case 224: s = coco_string_create(L"invalid params"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	error(line, col, s, path);
	//count++;
}

} // namespace

