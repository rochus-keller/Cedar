#ifndef __CEDAR_SYNTREE__
#define __CEDAR_SYNTREE__
// This file was automatically generated by EbnfStudio; don't modify it!

#include <Cedar/CedarTokenType.h>
#include <Cedar/CedarToken.h>
#include <QList>

namespace Cedar {

	struct SynTree {
		enum ParserRule {
			R_First = TT_Max + 1,
			R_access,
			R_arg,
			R_argList,
			R_arguments,
			R_block,
			R_catchItem,
			R_catchList,
			R_catch_,
			R_checking,
			R_comment_,
			R_conjunct,
			R_declaration,
			R_default_,
			R_definition,
			R_defsBody,
			R_defsHead,
			R_directory,
			R_disjunct,
			R_e,
			R_element,
			R_enable,
			R_entry,
			R_exit,
			R_exits,
			R_exports,
			R_factor,
			R_field,
			R_field_or_nfield,
			R_fields,
			R_for_,
			R_id,
			R_implBody,
			R_implHead,
			R_imports,
			R_include,
			R_initVal,
			R_interval,
			R_lastCatch,
			R_lhs,
			R_literal,
			R_locks,
			R_machineCode,
			R_module,
			R_negation,
			R_new_cons_list,
			R_nfield_,
			R_nvariant,
			R_open,
			R_openItem,
			R_params,
			R_prefixOp,
			R_primary,
			R_product,
			R_qualifiedName,
			R_range,
			R_relation,
			R_relationTail,
			R_repeat,
			R_s,
			R_safety,
			R_scope,
			R_sequence,
			R_shares,
			R_sum,
			R_t,
			R_tag,
			R_test,
			R_tilde,
			R_trash,
			R_typeApplication,
			R_typeConstructor,
			R_typeName,
			R_typeOp,
			R_union_,
			R_variant,
			R_while_,
			R_Last
		};
		SynTree(quint16 r = Tok_Invalid, const Token& = Token() );
		SynTree(const Token& t ):d_tok(t){}
		~SynTree() { foreach(SynTree* n, d_children) delete n; }

		static const char* rToStr( quint16 r );

		Cedar::Token d_tok;
		QList<SynTree*> d_children;
	};

}
#endif // __CEDAR_SYNTREE__
